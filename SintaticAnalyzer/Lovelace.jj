PARSER_BEGIN(Lovelace)
import java.io.*;
public class Lovelace {

  public static void main(String args[]) throws ParseException,IOException {
    
 	Lovelace analisador = new Lovelace(new FileInputStream(args[0]));
	try {
	analisador.Lovelace(); // Chama a regra inicial da gramática
		System.out.println("Analise sintatica concluida com sucesso.");
	} catch (ParseException e) {
		System.err.println("Erro sintatico: " + e.getMessage());
	}
  }

}

PARSER_END(Lovelace)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}


TOKEN :
{
  <MAIN: "main">
| <LET: "let">
| <APAR: "(">
| <FPAR: ")">  
| <BEGIN: "begin">
| <END: "end">
| <PV: ";">
| <VIRGULA: ",">
| <FLOAT: "Float">
| <BOOL: "Bool">
| <VOID: "Void">
| <ATR: ":=">
| <PRINT: "print">
| <IF: "if">
| <WHILE: "while">
| <RETURN: "return">
| <SOMA: "+">
| <SUB: "-">
| <DIV: "/">
| <MULT: "*">
| <AND: "&&">
| <OR: "||">
| <MAIOR: ">">
| <MENOR: "<">
| <IGUAL: "==">
| <READ: "read">
| <TRUE: "true">
| <FALSE: "false">
| <DEF: "def">
}


TOKEN :
{
  <NUMLITERAL: (["0"-"9"])+ ( "." (["0"-"9"])+ )? ( "E" (["+","-"])? (["0"-"9"])+ )? >

 |< ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"])* ( ["_"] ( ["a"-"z","A"-"Z","0"-"9"])*)*>
 
}

/* LOVELACE -> MAIN FUNC? */
void Lovelace() :
{}
{
    Main() Func() // sem "?" pois a regra Func já garante essa restrição
    <EOF>
}

/* MAIN -> "main" "("")" "begin" VARDECL SEQCOMANDOS "end" */
void Main() :
{}
{
    <MAIN> <APAR> <FPAR> <BEGIN>
    VarDecl()
    SeqComandos()
    <END>
}

/* * VARDECL -> VARDECL "let" TIPO TOKEN_id ";" | vazio
 * Removida recursão à esquerda: ( "let" TIPO ID ";" )*
 */
void VarDecl() :
{}
{
    (<LET> Tipo() <ID> <PV>)*
}

/* TIPO -> "Float" | "Bool" | "Void" */
void Tipo() :
{}
{
    <FLOAT> | <BOOL> | <VOID>
}

/* * SEQCOMANDOS -> SEQCOMANDOS COMANDO | vazio
 * Removida recursão à esquerda: ( COMANDO )*
 */
void SeqComandos() :
{}
{
    (Comando())*
}

/*
 * COMANDO -> (diversas opções)
 * Resolvida ambiguidade do TOKEN_id com fatoração.
 
 * Fatoração das regras que começam com <ID>:
 * 1. TOKEN_id ":=" EXP ";"
 * 2. TOKEN_id "(" LISTAEXP? ")" ";"
 * 3. TOKEN_id ":=" "read" "(" ")" ";"
*/
void Comando() :
{}
{
    (
        <ID>
        (
            ( <ATR> // Regras 1 e 3 (ambas têm ":=")
                (
                    <READ> <APAR> <FPAR> <PV>
                |
                    Exp() <PV>
                )
            )
        |
            ( <APAR> ( ListaExp() )? <FPAR> <PV> )
        )
    )
    |
    ( <IF> Exp() <BEGIN> SeqComandos() <END> <PV> )
    |
    ( <BEGIN> SeqComandos() <END> <PV> )
    |
    ( <WHILE> Exp() <BEGIN> SeqComandos() <END> <PV> ) 
    |
    ( <RETURN> Exp() <PV> )
    |
    ( <PRINT> Exp() <PV> )
}

/* EXP -> "(" EXP OP EXP ")" | FATOR */
void Exp() :
{}
{
    ( <APAR> Exp() Op() Exp() <FPAR> )
    |
    Fator()
}

/* * FATOR -> TOKEN_id | TOKEN_id "(" LISTAEXP? ")" | TOKEN_numliteral | "true" | "false"
 * Resolvida ambiguidade do TOKEN_id com fatoração.
 */
void Fator() :
{}
{
    (
        /* * Agrupa "TOKEN_id" e "TOKEN_id ( LISTAEXP? )" */
        <ID> ( <APAR> ( ListaExp() )? <FPAR> )?
    )
    |
    <NUMLITERAL>
    |
    <TRUE>
    |
    <FALSE>
}

/* OP -> "+" | "-" | "*" | "/" | "&&" | "||" | "<" | ">" | "==" */
void Op() :
{}
{
    <SOMA> | <SUB> | <MULT> | <DIV> | <AND> | <OR> | <MENOR> | <MAIOR> | <IGUAL>
}

/* * LISTAEXP -> EXP | LISTAEXP "," EXP
 * Removida recursão à esquerda: EXP ( "," EXP )*
 */
void ListaExp() :
{}
{
    Exp() ( <VIRGULA> Exp() )*
}

/* * FUNC -> FUNC "def" ... | "def" ... 
 * Removida recursão à esquerda: ( "def" ... )*
 */
void Func() :
{}
{
    (
        <DEF> Tipo() <ID> <APAR> ( ListaArg() )? <FPAR> <BEGIN> VarDecl() SeqComandos() <END>
    )*
}

/* * LISTAARG -> TIPO TOKEN_id | LISTAARG "," TIPO TOKEN_id
 * Removida recursão à esquerda: TIPO ID ( "," TIPO ID )*
 */
void ListaArg() :
{}
{
    Tipo() <ID> ( <VIRGULA> Tipo() <ID> )*
}